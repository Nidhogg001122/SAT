#include "def.h"

//读取棋盘
status Read_checkboard(char* filename,struct board* check)
{
	FILE* fp = fopen(filename, "r");
	if (!fp) return NULL;
	int judge = 0,i=1;
	fscanf(fp, "%d", &judge);
	while (judge != -1)
	{
		if (judge == 1)
		{
			check[i].empty = 0;
			check[i].num = 1;
		}
		if (!judge)
		{
			check[i].empty = 0;
			check[i].num = 0;
		}
		if (judge == 2)
		{
			check[i].empty = 1;
			check[i].num = -1;
		}
		i++;
		fscanf(fp, "%d", &judge);
	}
	fclose(fp);
	return i-1;
}

//展示棋盘
void show_check(struct board* check,int board_num)
{
	int i = 1,j=0,board_line=0;
	board_line = sqrt(board_num);
	for (; i < board_num;)
	{
		for (j = 0; j < board_line; j++,i++)
		{
			if (check[i].empty) printf("_ ");
			else printf("%d ", check[i].num);
		}
		printf("\n");
	}
}

//棋盘转化为CNF
status check_to_cnf(struct board* check,char* filename,int board_num)
{
	FILE* fp = fopen(filename, "w");
	int num = 0;
	if (!fp) return NULL;
	else
	{
		fprintf(fp, "                  \n");
		int check_line = sqrt(board_num), i = 0, j = 0,k=0;
		//处理已有条件
		for (i = 1; i <= board_num; i++)		
		{
			if (!check[i].empty)
			{
				if (check[i].num) fprintf(fp, "%d 0\n", i),num++;
				else fprintf(fp, "%d 0\n", -i),num++;
			}
		}
		//处理连续一行内连续三个不能相同
		for (i = 1; i <= board_num - check_line+1; i += check_line)
		{
			for (j = i;j <= i + check_line-3;j++)
			{
					fprintf(fp, "%d %d %d 0\n", j,j+1,j+2);
					fprintf(fp, "%d %d %d 0\n", -j,-j-1,-j-2);
					num += 2;
			}
		}
		//处理连续一列内连续三个不能相同
		for (i = 1; i <= check_line ; i ++)
		{
			for (j = i; j < i+4*check_line ; j+=check_line)
			{
				fprintf(fp, "%d %d %d 0\n", j, j + check_line, j + 2*check_line);
				fprintf(fp, "%d %d %d 0\n", -j, -j - check_line, -j - 2*check_line);
				num += 2;
			}
		}
		/*
		* 2020.03.07
		每行0与1数目相同
		对于六阶，即任意四位里至少有一个与其他三个相同的不同，
		利用循环很难找出全部随机四个，直接利用数组列出所有值
		*/
		if (check_line == 6)
		{
			int add[15][4] = { {0,1,2,3},{0,1,2,4},{0,1,2,5},{0,1,3,4},{0,1,3,5},{0,1,4,5},
				{0,2,3,4},{0,2,3,5},{0,2,4,5},{0,3,4,5},{1,2,3,4},{1,2,3,5},{1,2,4,5},{1,3,4,5},
				{2,3,4,5}
			};
			for (i = 1; i <= board_num - check_line + 1; i += check_line)
			{
				for (j = 0; j < 15; j++)
				{
					for (k = 0; k < 4; k++)
					{
						fprintf(fp, "%d ", i + add[j][k]);
					}
					fprintf(fp, "0\n");
					for (k = 0; k < 4; k++)
					{
						fprintf(fp, "%d ", -i - add[j][k]);
					}
					fprintf(fp, "0\n");
					num += 2;
				}
			}
			//每列0与1数目相同
			for (i = 1; i <= check_line; i++)
			{
				for (j = 0; j < 15; j++)
				{
					for (k = 0; k < 4; k++)
					{
						fprintf(fp, "%d ", i + check_line * add[j][k]);
					}

					fprintf(fp, "0\n");
					for (k = 0; k < 4; k++)
					{
						fprintf(fp, "%d ", -i - check_line * add[j][k]);
					}
					fprintf(fp, "0\n");
					num += 2;
				}
			}
		}
		else if (check_line == 8)
		{
			int add[56][5] = { {0,1,2,3,4},{0,1,2,3,5},{0,1,2,3,6},{0,1,2,3,7},{0,1,2,4,5},{0,1,2,4,6},
			{0,1,2,4,7},{0,1,2,5,6},{0,1,2,5,7},{0,1,2,6,7},{0,1,3,4,5},{0,1,3,4,6},{0,1,3,4,7},{0,1,3,5,6},{0,1,3,5,7},{0,1,3,6,7},
			{0,1,4,5,6},{0,1,4,5,7},{0,1,4,6,7},{0,1,5,6,7},{0,2,3,4,5},{0,2,3,4,6},{0,2,3,4,7},{0,2,3,5,6},{0,2,3,5,7},{0,2,3,6,7},
			{0,2,4,5,6},{0,2,4,5,7},{0,2,4,6,7},{0,2,5,6,7},{0,3,4,5,6},{0,3,4,5,7},{0,3,4,6,7},{0,3,5,6,7},{0,4,5,6,7},{1,2,3,4,5},
			{1,2,3,4,6},{1,2,3,4,7},{1,2,3,5,6},{1,2,3,5,7},{1,2,3,6,7},{1,2,4,5,6},{1,2,4,5,7},{1,2,4,6,7},{1,2,5,6,7},{1,3,4,5,6},
			{1,3,4,5,7},{1,3,4,6,7},{1,3,5,6,7},{1,4,5,6,7},{2,3,4,5,6},{2,3,4,5,7},{2,3,4,6,7},{2,3,5,6,7},{2,4,5,6,7},{3,4,5,6,7},
			};
			for (i = 1; i <= board_num - check_line + 1; i += check_line)
			{
				for (j = 0; j < 56; j++)
				{
					for (k = 0; k < 5; k++)
					{
						fprintf(fp, "%d ", i + add[j][k]);
					}
					fprintf(fp, "0\n");
					for (k = 0; k < 5; k++)
					{
						fprintf(fp, "%d ", -i - add[j][k]);
					}
					fprintf(fp, "0\n");
					num += 2;
				}
			}
			//每列0与1数目相同
			for (i = 1; i <= check_line; i++)
			{
				for (j = 0; j < 56; j++)
				{
					for (k = 0; k < 5; k++)
					{
						fprintf(fp, "%d ", i + check_line * add[j][k]);
					}

					fprintf(fp, "0\n");
					for (k = 0; k < 5; k++)
					{
						fprintf(fp, "%d ", -i - check_line * add[j][k]);
					}
					fprintf(fp, "0\n");
					num += 2;
				}
			}
		}
		else if (check_line == 10)
		{
		int add[210][6] = {
{0,1,2,3,4,5},{0,1,2,3,4,6},{0,1,2,3,4,7},{0,1,2,3,4,8},{0,1,2,3,4,9},{0,1,2,3,5,6},{0,1,2,3,5,7},{0,1,2,3,5,8},{0,1,2,3,5,9},{0,1,2,3,6,7},
{0,1,2,3,6,8},{0,1,2,3,6,9},{0,1,2,3,7,8},{0,1,2,3,7,9},{0,1,2,3,8,9},{0,1,2,4,5,6},{0,1,2,4,5,7},{0,1,2,4,5,8},{0,1,2,4,5,9},{0,1,2,4,6,7},
{0,1,2,4,6,8},{0,1,2,4,6,9},{0,1,2,4,7,8},{0,1,2,4,7,9},{0,1,2,4,8,9},{0,1,2,5,6,7},{0,1,2,5,6,8},{0,1,2,5,6,9},{0,1,2,5,7,8},{0,1,2,5,7,9},
{0,1,2,5,8,9},{0,1,2,6,7,8},{0,1,2,6,7,9},{0,1,2,6,8,9},{0,1,2,7,8,9},{0,1,3,4,5,6},{0,1,3,4,5,7},{0,1,3,4,5,8},{0,1,3,4,5,9},{0,1,3,4,6,7},
{0,1,3,4,6,8},{0,1,3,4,6,9},{0,1,3,4,7,8},{0,1,3,4,7,9},{0,1,3,4,8,9},{0,1,3,5,6,7},{0,1,3,5,6,8},{0,1,3,5,6,9},{0,1,3,5,7,8},{0,1,3,5,7,9},
{0,1,3,5,8,9},{0,1,3,6,7,8},{0,1,3,6,7,9},{0,1,3,6,8,9},{0,1,3,7,8,9},{0,1,4,5,6,7},{0,1,4,5,6,8},{0,1,4,5,6,9},{0,1,4,5,7,8},{0,1,4,5,7,9},
{0,1,4,5,8,9},{0,1,4,6,7,8},{0,1,4,6,7,9},{0,1,4,6,8,9},{0,1,4,7,8,9},{0,1,5,6,7,8},{0,1,5,6,7,9},{0,1,5,6,8,9},{0,1,5,7,8,9},{0,1,6,7,8,9},
{0,2,3,4,5,6},{0,2,3,4,5,7},{0,2,3,4,5,8},{0,2,3,4,5,9},{0,2,3,4,6,7},{0,2,3,4,6,8},{0,2,3,4,6,9},{0,2,3,4,7,8},{0,2,3,4,7,9},{0,2,3,4,8,9},
{0,2,3,5,6,7},{0,2,3,5,6,8},{0,2,3,5,6,9},{0,2,3,5,7,8},{0,2,3,5,7,9},{0,2,3,5,8,9},{0,2,3,6,7,8},{0,2,3,6,7,9},{0,2,3,6,8,9},{0,2,3,7,8,9},
{0,2,4,5,6,7},{0,2,4,5,6,8},{0,2,4,5,6,9},{0,2,4,5,7,8},{0,2,4,5,7,9},{0,2,4,5,8,9},{0,2,4,6,7,8},{0,2,4,6,7,9},{0,2,4,6,8,9},{0,2,4,7,8,9},
{0,2,5,6,7,8},{0,2,5,6,7,9},{0,2,5,6,8,9},{0,2,5,7,8,9},{0,2,6,7,8,9},{0,3,4,5,6,7},{0,3,4,5,6,8},{0,3,4,5,6,9},{0,3,4,5,7,8},{0,3,4,5,7,9},
{0,3,4,5,8,9},{0,3,4,6,7,8},{0,3,4,6,7,9},{0,3,4,6,8,9},{0,3,4,7,8,9},{0,3,5,6,7,8},{0,3,5,6,7,9},{0,3,5,6,8,9},{0,3,5,7,8,9},{0,3,6,7,8,9},
{0,4,5,6,7,8},{0,4,5,6,7,9},{0,4,5,6,8,9},{0,4,5,7,8,9},{0,4,6,7,8,9},{0,5,6,7,8,9},{1,2,3,4,5,6},{1,2,3,4,5,7},{1,2,3,4,5,8},{1,2,3,4,5,9},
{1,2,3,4,6,7},{1,2,3,4,6,8},{1,2,3,4,6,9},{1,2,3,4,7,8},{1,2,3,4,7,9},{1,2,3,4,8,9},{1,2,3,5,6,7},{1,2,3,5,6,8},{1,2,3,5,6,9},{1,2,3,5,7,8},
{1,2,3,5,7,9},{1,2,3,5,8,9},{1,2,3,6,7,8},{1,2,3,6,7,9},{1,2,3,6,8,9},{1,2,3,7,8,9},{1,2,4,5,6,7},{1,2,4,5,6,8},{1,2,4,5,6,9},{1,2,4,5,7,8},
{1,2,4,5,7,9},{1,2,4,5,8,9},{1,2,4,6,7,8},{1,2,4,6,7,9},{1,2,4,6,8,9},{1,2,4,7,8,9},{1,2,5,6,7,8},{1,2,5,6,7,9},{1,2,5,6,8,9},{1,2,5,7,8,9},
{1,2,6,7,8,9},{1,3,4,5,6,7},{1,3,4,5,6,8},{1,3,4,5,6,9},{1,3,4,5,7,8},{1,3,4,5,7,9},{1,3,4,5,8,9},{1,3,4,6,7,8},{1,3,4,6,7,9},{1,3,4,6,8,9},
{1,3,4,7,8,9},{1,3,5,6,7,8},{1,3,5,6,7,9},{1,3,5,6,8,9},{1,3,5,7,8,9},{1,3,6,7,8,9},{1,4,5,6,7,8},{1,4,5,6,7,9},{1,4,5,6,8,9},{1,4,5,7,8,9},
{1,4,6,7,8,9},{1,5,6,7,8,9},{2,3,4,5,6,7},{2,3,4,5,6,8},{2,3,4,5,6,9},{2,3,4,5,7,8},{2,3,4,5,7,9},{2,3,4,5,8,9},{2,3,4,6,7,8},{2,3,4,6,7,9},
{2,3,4,6,8,9},{2,3,4,7,8,9},{2,3,5,6,7,8},{2,3,5,6,7,9},{2,3,5,6,8,9},{2,3,5,7,8,9},{2,3,6,7,8,9},{2,4,5,6,7,8},{2,4,5,6,7,9},{2,4,5,6,8,9},
{2,4,5,7,8,9},{2,4,6,7,8,9},{2,5,6,7,8,9},{3,4,5,6,7,8},{3,4,5,6,7,9},{3,4,5,6,8,9},{3,4,5,7,8,9},{3,4,6,7,8,9},{3,5,6,7,8,9},{4,5,6,7,8,9}
		};
			for (i = 1; i <= board_num - check_line + 1; i += check_line)
			{
				for (j = 0; j < 210; j++)
				{
					for (k = 0; k < 6; k++)
					{
						fprintf(fp, "%d ", i + add[j][k]);
					}
					fprintf(fp, "0\n");
					for (k = 0; k < 6; k++)
					{
						fprintf(fp, "%d ", -i - add[j][k]);
					}
					fprintf(fp, "0\n");
					num += 2;
				}
			}
			//每列0与1数目相同
			for (i = 1; i <= check_line; i++)
			{
				for (j = 0; j < 210; j++)
				{
					for (k = 0; k < 6; k++)
					{
						fprintf(fp, "%d ", i + check_line * add[j][k]);
					}

					fprintf(fp, "0\n");
					for (k = 0; k < 6; k++)
					{
						fprintf(fp, "%d ", -i - check_line * add[j][k]);
					}
					fprintf(fp, "0\n");
					num += 2;
				}
			}
		}
			/*
			* 2021.03.08
			* 实现每两行或两列之间不同
			* 以第一和第二行之间为例子，若两行不同（两行相同取反），11表示第一行第一个元素，其余同理
			* ¬{[（11∧21）∨（¬11∧¬21）]∧[（12∧22）∨（¬12∧¬22）] ∧…∧[（16∧26）∨（¬16∧¬26）]}
			* 引入变元
			* a=11∧21,	b=¬11∧¬21,	c=a∨b=[（11∧21）∨（¬11∧¬21）]
			* d=12∧22, e=¬12∧¬22, f=d∧e=[（12∧22）∨（¬12∧¬22）]
			* ..........
			* 同理引入更多变元
			* 对于a=11∧21转化为CNF:（11∨¬a）∧（21∨¬a）∧（¬11∨¬21∨a）形成3个子句
			* 对于b=¬11∧¬21同理
			* 对于c=a∨b转化为CNF: (¬a∨c)∧(¬b∨c)∧(a∨b∨¬c) 形成3个子句
			* 故两行之间同一列一个变元形成9个子句
			* 
			* 对于最终¬{[（11∧21）∨（¬11∧¬21）]∧[（12∧22）∨（¬12∧¬22）] ∧…∧[（16∧26）∨（¬16∧¬26）]}
			* 引进变元展开后已经形成CNF，故不必引入子句
			* 
			* 为了方便运算，而且我也找不到太多字母，引入的变元使用棋盘未占用的后续数字
			*/

			//各行之间各不相同
			int next, now = board_num+1;
			for (i = 1; i <= check_line; i++) {
				for (j = i + 1; j <= check_line; j++) {
					for (k = 1; k <= check_line; k++) {
						fprintf(fp, "%d %d 0\n", (i-1)*check_line + k, -now);
						fprintf(fp, "%d %d 0\n", (j-1)*check_line + k, -now);
						fprintf(fp, "%d %d %d 0\n", -(i - 1)* check_line - k, -(j - 1)* check_line - k, now);
			
						fprintf(fp, "%d %d 0\n", -(i - 1)* check_line - k, -now-1);
						fprintf(fp, "%d %d 0\n", -(j - 1)* check_line - k, -now-1);
						fprintf(fp, "%d %d %d 0\n", (i - 1) * check_line + k, (j - 1) * check_line + k, now+1);
						
						fprintf(fp, "%d %d 0\n",-now , now + 2);
						fprintf(fp, "%d %d 0\n",-now-1 , now + 2);
						fprintf(fp, "%d %d %d 0\n", now, now + 1,now+2);

						now+=3;
						num += 9;
					}
				}
			}

			//各列之间各不相同
			for (i = 1; i <= check_line; i++) {
				for (j = i + 1; j <= check_line; j++) {
					for (k = 1; k <= check_line; k++) {
						fprintf(fp, "%d %d 0\n", (k - 1) * check_line + i, -now);
						fprintf(fp, "%d %d 0\n", (k - 1) * check_line + j, -now);
						fprintf(fp, "%d %d %d 0\n", -(k - 1) * check_line - i, -(k - 1) * check_line - j, now);

						fprintf(fp, "%d %d 0\n", -(k - 1) * check_line - i, -now - 1);
						fprintf(fp, "%d %d 0\n", -(k - 1) * check_line - j, -now - 1);
						fprintf(fp, "%d %d %d 0\n", (k - 1) * check_line + i, (k - 1) * check_line + j, now + 1);

						fprintf(fp, "%d %d 0\n", -now, now + 2);
						fprintf(fp, "%d %d 0\n", -now - 1, now + 2);
						fprintf(fp, "%d %d %d 0\n", now, now + 1, now + 2);

						now += 3;
						num += 9;
					}
				}
			}
			fseek(fp, 0, 0);
			fprintf(fp, "p cnf %d %d", now, num);
	}
	printf("转化成功,即将继续求解\n\n");
	system("pause");
	fclose(fp);
	return 1;
}

//play
void PlaySuDoKu(struct board* qipan,int board_num) {
	printf("当前棋盘：\n");
	show_check(qipan,board_num);
	printf("请分别输入1或0来填补空缺：\n");
	int answer[108] = { -1 };
	for (int i = 1; i < board_num; i++) {
		scanf("%d", &answer[i]);
	}

	system("pause");
}